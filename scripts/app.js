document.addEventListener('DOMContentLoaded', () => {
  window.showErrorToast = showErrorToast;
  // lightweight party id -> name map (generated by preprocess_party_names.js)
  const PARTY_NAMES = {};
  (async function loadPartyNames(){
    try {
      const r = await fetch('data/party_names.json', { cache: 'no-store' });
      if (!r.ok) return;
      Object.assign(PARTY_NAMES, await r.json());
      console.log('[APP] loaded party_names.json', Object.keys(PARTY_NAMES).length);
      // expose for debugging
      window.PARTY_NAMES = PARTY_NAMES;
    } catch(e){ /* ignore */ }
  })();

  // ---------- sliders / radios / reset ----------
  const sliders = Array.from(document.querySelectorAll('.slider-row input[type="range"], .range input[type="range"]'));
  const radios  = Array.from(document.querySelectorAll('input[type="radio"]'));

  const resetBtn = document.querySelector('.toolbar .reset, [data-action="reset"], .control-panel .reset, button.reset');
  let   applyBtn = document.querySelector('.toolbar .apply, [data-action="apply"], .control-panel .apply, button.apply')
           || Array.from(document.querySelectorAll('button, .btn')).find(b => (b.textContent||'').trim().toLowerCase()==='apply');

  // View Results pill (FAB)
  const viewFab = document.querySelector('.fab-to-results');
  let allowFab = true;
  let fabAutoHidden = false;

  // Download button (disabled until a successful Apply)
  const downloadBtn = document.querySelector('.map-actions .btn.ghost');
  if (downloadBtn) {
    downloadBtn.classList.add('is-disabled');
    downloadBtn.setAttribute('aria-disabled', 'true');
  }
  // prevent clicks on the download control while it's disabled and show a toast
  const mapActions = document.querySelector('.map-actions');
  if (mapActions) {
    mapActions.addEventListener('click', (ev) => {
      const btn = ev.target.closest('.btn.ghost');
      if (!btn) return;
      // If the download button is disabled, show an error toast instead of letting the click pass through
      if (btn === downloadBtn && (downloadBtn.classList.contains('is-disabled') || downloadBtn.getAttribute('aria-disabled') === 'true')) {
        ev.preventDefault();
        ev.stopPropagation();
        showErrorToast('No results to download — click Apply first.');
      }
    });
  }

  window.addEventListener('scroll', () => {
    if (!viewFab || fabAutoHidden) return;

    // user scrolled meaningfully
    if (window.scrollY > 80) {
      viewFab.classList.add('is-hidden');
      fabAutoHidden = true;
    }
  });

  (function injectFabStyles(){
    const css = `
      .fab-to-results{
        position: fixed;
        left: 50%;
        bottom: max(22px, env(safe-area-inset-bottom, 0px) + 12px);
        transform: translateX(-50%) translateY(0);
        z-index: 1400;
        display: inline-flex;
        align-items: center;
        gap: .45rem;
        white-space: nowrap;
        padding: .55rem 1.05rem;
        border-radius: 28px;
        background: var(--blue-900, #3b5bd8);
        color: #fff;
        box-shadow: 0 8px 24px rgba(46,61,88,0.12);
        cursor: pointer;
        transition: transform .18s ease, opacity .22s ease, visibility .22s ease;
        will-change: transform, opacity;
      }
      .fab-to-results.is-hidden{
        opacity: 0;
        visibility: hidden;
        pointer-events: none;
        transform: translateX(-50%) translateY(8px);
      }
      .fab-to-results.is-bounce{
        animation: fab-bounce .9s ease-in-out 1;
      }
      @keyframes fab-bounce{
        0%,100%{ transform: translateX(-50%) translateY(0); }
        35%   { transform: translateX(-50%) translateY(-8px); }
        70%   { transform: translateX(-50%) translateY(-4px); }
      }
      /* Slightly higher on very wide layouts so it doesn't overlap content shadow */
      @media (min-width:1400px){
        .fab-to-results{ bottom: 40px; }
      }
    `;
    const s=document.createElement('style'); s.textContent=css; document.head.appendChild(s);
  })();

  // hide FAB until the first real Apply
  viewFab?.classList.add('is-hidden');

  viewFab?.classList.add('is-hidden');

  // --- REPLACE the dynamic import(...) block with this fetch-based loader + visual status badge ---
  (function loadEPDataAndInit() {
    const STATUS_ID = 'rm-epdata-status';

    function setStatus(loaded, keys = []) {
      let el = document.getElementById(STATUS_ID);
      if (!el) {
        el = document.createElement('div');
        el.id = STATUS_ID;
        Object.assign(el.style, {
          position: 'fixed',
          right: '18px',
          top: '86px',
          zIndex: '1500',
          padding: '8px 12px',
          borderRadius: '999px',
          fontSize: '13px',
          boxShadow: '0 8px 20px rgba(20,30,60,0.08)',
          display: 'flex',
          gap: '8px',
          alignItems: 'center',
          background: '#fff'
        });
        document.body.appendChild(el);
      }
      el.innerHTML = '';
      const dot = document.createElement('span');
      Object.assign(dot.style, {
        width: '10px',
        height: '10px',
        borderRadius: '50%',
        display: 'inline-block'
      });
      const text = document.createElement('span');
      // if (loaded) {
      //   dot.style.background = '#10B981'; // green
      //   // text.textContent = `EP data loaded — ${keys.length} countries`;
      //   text.textContent = `Loaded.`;
      // } else {
      //   dot.style.background = '#EF4444'; // red
      //   text.textContent = 'NOT loaded';
      // }
      el.appendChild(dot);
      el.appendChild(text);
    }

    async function tryLoad() {
      try {
        // Use relative path so Live Server resolves correctly
        const resp = await fetch('data/ep2024_processed.json', { cache: 'no-store' });
        if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
        const data = await resp.json();
        window.epData = data;
        console.log('[APP] Loaded EP data (keys):', Object.keys(data || {}));
        setStatus(true, Object.keys(data || {}));

        // send a quick dev ping to log-receiver (IDE) to confirm connectivity
        try {
          await fetch('http://127.0.0.1:9999/log', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({ ts: new Date().toISOString(), source: 'app.init', msg: 'data_loaded', keys: Object.keys(data || {}) })
          });
          console.log('[APP] dev log posted to log-receiver');
        } catch (e) {
          console.debug('[APP] log-receiver not reachable:', e.message);
        }

        // only auto-run apply for test if applyChanges exists and a valid dropdown selection is present
        if (typeof applyChanges === 'function') {
          // don't auto-run if user already selected nothing; safe test run
          console.log('[APP] ready — apply available');
        }
      } catch (err) {
        console.error('[APP] Failed to load ep2024_processed.json', err);
        setStatus(false);
        console.warn('[APP] EP data not loaded — continuing without data. User can try Apply later.');
      }
    }

    tryLoad();
  })();

  const initialSliderValue = new WeakMap();
  sliders.forEach(input => {
    const valueEl = input.parentElement.querySelector('.value');
    const upd = () => { if (valueEl) valueEl.textContent = `${input.value}%`; };
    upd(); input.addEventListener('input', upd); input.addEventListener('change', upd);
    initialSliderValue.set(input, input.value);
  });

  const radioGroupDefault = new Map();
  radios.forEach(r => {
    const name = r.name || ('__g'+Math.random());
    if (!radioGroupDefault.has(name)) radioGroupDefault.set(name, null);
    if (r.checked && radioGroupDefault.get(name) === null) radioGroupDefault.set(name, r);
    if (radioGroupDefault.get(name) === null) radioGroupDefault.set(name, radios.find(x => x.name === name));
  });

  resetBtn?.addEventListener('click', () => {
    // hard refresh keeps everything in a clean base state
    window.location.reload();
  });

  // ---------- dropdowns ----------
  const Dropdowns = (() => {
    const instances = new Map();

    function closeAll(except = null) {
      instances.forEach((inst, el) => {
        if (except && el === except) return;
        inst.close();
      });
    }

    function setLabel(toggle, text) {
      const l = toggle.querySelector('.dropdown-label');
      if (l) l.textContent = text; else toggle.textContent = `${text} ▾`;
    }

    // helpers to animate a menu element
    function expandMenu(el) {
      if (!el) return;
      el.style.display = '';
      const full = el.scrollHeight + 'px';
      el.style.height = '0px';
      el.style.opacity = '0';
      requestAnimationFrame(() => {
        el.style.transition = 'height .28s cubic-bezier(.2,.9,.2,1), opacity .18s ease';
        el.style.height = full;
        el.style.opacity = '1';
      });
      const onEnd = (e) => {
        if (e.propertyName === 'height') {
          el.removeEventListener('transitionend', onEnd);
          el.style.height = 'auto';
          el.style.transition = '';
        }
      };
      el.addEventListener('transitionend', onEnd);
    }

    function collapseMenu(el, cb) {
      if (!el) { if (cb) cb(); return; }
      // from auto -> explicit px so transition works
      el.style.height = el.scrollHeight + 'px';
      el.style.opacity = '1';
      requestAnimationFrame(() => {
        el.style.transition = 'height .22s cubic-bezier(.2,.9,.2,1), opacity .14s ease';
        el.style.height = '0px';
        el.style.opacity = '0';
      });
      const onEnd = (e) => {
        if (e.propertyName === 'height') {
          el.removeEventListener('transitionend', onEnd);
          el.style.display = 'none';
          el.style.transition = '';
          if (typeof cb === 'function') cb();
        }
      };
      el.addEventListener('transitionend', onEnd);
    }

    function wire(rootEl, items = [], { enableSearch = false } = {}) {
      const t = rootEl.querySelector('.dropdown-toggle');
      const m = rootEl.querySelector('.dropdown-menu');
      const list = rootEl.querySelector('.dropdown-list');
      const search = rootEl.querySelector('.dropdown-search');

      if (list && items.length) {
        list.innerHTML = '';
        items.forEach(name => {
          const it = document.createElement('div');
          it.className = 'item';
          it.tabIndex = 0;
          it.dataset.value = name;
          it.textContent = name;
          list.appendChild(it);
        });
      }

      const open = () => {
        closeAll(rootEl);
        rootEl.setAttribute('data-opening', '1');
        window.__dropdownOpening = true;
        setTimeout(() => {
          rootEl.removeAttribute('data-opening');
          window.__dropdownOpening = false;
        }, 180);
        rootEl.classList.add('open');
        t.setAttribute('aria-expanded', 'true');
        if (m) {
          expandMenu(m);
          // try { m.focus({ preventScroll: true }); } catch (e) { /* ignore */ }
        }
      };

      const close = () => {
        // animate then remove "open" class when done
        if (m) {
          collapseMenu(m, () => {
            rootEl.classList.remove('open');
            t.setAttribute('aria-expanded', 'false');
          });
        } else {
          rootEl.classList.remove('open');
          t.setAttribute('aria-expanded', 'false');
        }
      };

      t.addEventListener('click', e => {
        e.stopPropagation();
        // record the moment the toggle was clicked so the document click
        // handler can ignore any immediately following clicks
        window.__lastDropdownToggle = (typeof performance !== 'undefined') ? performance.now() : Date.now();

        const willOpen = !rootEl.classList.contains('open');
        if (willOpen) open(); else close();
      });

      m?.addEventListener('click', e => e.stopPropagation());

      list?.addEventListener('click', ev => {
        const it = ev.target.closest('.item'); if (!it) return;
        setLabel(t, it.dataset.value);
        list.querySelectorAll('.item[aria-selected="true"]').forEach(x => x.setAttribute('aria-selected', 'false'));
        it.setAttribute('aria-selected', 'true');
        // close dropdown smoothly
        close();
        // blur focused element
        try { if (document.activeElement && typeof document.activeElement.blur === 'function') document.activeElement.blur(); } catch (e) {}
        requestAnimationFrame(() => closeAll());
        rootEl.dispatchEvent(new CustomEvent('dropdown-change', { detail: { value: it.dataset.value } }));
      });

      list?.addEventListener('keydown', ev => {
        const a = document.activeElement;
        if (ev.key === 'ArrowDown') { ev.preventDefault(); (a.nextElementSibling || a).focus(); }
        if (ev.key === 'ArrowUp') { ev.preventDefault(); (a.previousElementSibling || a).focus(); }
        if (ev.key === 'Enter') { ev.preventDefault(); a.click(); }
        if (ev.key === 'Escape') { closeAll(); t.focus(); }
      });

      if (enableSearch && search && list) {
        search.addEventListener('input', () => {
          const q = search.value.trim().toLowerCase();
          Array.from(list.children).forEach(it => it.style.display = (!q || it.textContent.toLowerCase().includes(q)) ? '' : 'none');
        });
      }

      if (m) {
        if (!rootEl.classList.contains('open')) {
          m.style.display = 'none';
          m.style.height = '0px';
          m.style.opacity = '0';
        } else {
          m.style.display = '';
          m.style.height = 'auto';
          m.style.opacity = '1';
        }
      }

      return { close };
    }

    return { wire, closeAll };
  })();

  // attach dropdowns
  const euCountries = [
    "Austria","Belgium","Bulgaria","Croatia","Cyprus","Czechia",
    "Denmark","Estonia","Finland","France","Germany","Greece","Hungary","Ireland",
    "Italy","Latvia","Lithuania","Luxembourg","Malta","Netherlands","Poland",
    "Portugal","Romania","Slovakia","Slovenia","Spain","Sweden"
  ].sort((a,b)=>a.localeCompare(b));

  const EU_CODES = {
    "Austria": "AT","Belgium":"BE","Bulgaria":"BG","Croatia":"HR","Cyprus":"CY","Czechia":"CZ",
    "Denmark":"DK","Estonia":"EE","Finland":"FI","France":"FR","Germany":"DE","Greece":"EL","Hungary":"HU","Ireland":"IE",
    "Italy":"IT","Latvia":"LV","Lithuania":"LT","Luxembourg":"LU","Malta":"MT","Netherlands":"NL","Poland":"PL",
    "Portugal":"PT","Romania":"RO","Slovakia":"SK","Slovenia":"SI","Spain":"ES","Sweden":"SE"
  };
  
  const countryDD  = document.querySelector('.select-control.pill .dropdown[data-dropdown="country"]');
  countryDD && Dropdowns.wire(countryDD,  euCountries, { enableSearch:true  });
  
  // Show default empty table before the first Apply
  renderEmptyMetricsPlaceholder();

  // ---------- legend render (only on Apply) ----------
  const sliderEls = Array.from(document.querySelectorAll('.control-card .slider-row input'));
  const thresholdSlider = sliderEls[0] || null;
  const dmSlider        = sliderEls[1] || null;

  const getTxt = (sel, def='') => document.querySelector(sel)?.textContent?.trim() || def;
  const currentCountry  = () => getTxt('.dropdown[data-dropdown="country"] .dropdown-label', 'Country');
  // const currentScenario = () => getTxt('.dropdown[data-dropdown="scenario"] .dropdown-label', '');
  function currentFormula(){
    const c = document.querySelector('label.formula input[type="radio"]:checked');
    const l = c?.closest('label.formula')?.querySelector('.text')?.textContent?.trim();
    return l || 'Formula';
  }
  function currentDmMode(){
    const m = document.querySelector('input[name="dm-mode"]:checked');
    const lbl = m ? document.querySelector(`label[for="${m.id}"]`) : null;
    return lbl ? lbl.textContent.trim() : '';
  }
  const dmMagnitudeValue = () => Math.max(1, Math.round(Number(dmSlider?.value||0)) + 2);

  function readState(){
    const thr = thresholdSlider ? Number(thresholdSlider.value) : 0;
    const rawCountry = currentCountry();
    const country = (rawCountry === 'Country' || rawCountry === '') ? '' : rawCountry;
    return {
      country:  country,
      // scenario: currentScenario(),
      threshold: thr,
      formula:  currentFormula(),
      dmMode:   currentDmMode(),
      dmMag:    dmMagnitudeValue()
    };
  }
  function renderLegend(s){
    const meta = document.querySelector('.map-meta');
    const intro = document.querySelector('.legend-intro');
    if (meta){
      // const parts = [
      //   s.country,
      //   `<span class="meta-accent">Threshold ${s.threshold}%</span>`,
      //   s.formula,
      //   `District magnitude ${s.dmMag}${s.dmMode?` (${s.dmMode})`:''}`
      // ];
      const parts = [
        s.country || '<span class="meta-muted">Country</span>',
        `<span class="meta-accent">Threshold ${s.threshold}%</span>`,
        s.formula,
        `District magnitude ${s.dmMag}${s.dmMode?` (${s.dmMode})`:''}`
      ];
      // if (s.scenario && s.scenario !== 'Scenario') parts.splice(1,0,s.scenario);
      meta.innerHTML = parts.join(' → ');
      meta.style.fontSize = '0.95rem';
    }
    if (intro){
      intro.textContent = `Seats shifted once the threshold rose to ${s.threshold}%. Districts with smaller magnitudes (≈ ${s.dmMag}) are more volatile.`;
    }
  }

  // ---------- ADD: metrics helpers & renderer (place BEFORE applyChanges) ----------
  // smooth counter
  function animateCount(el, from, to, ms = 800, fmt = v => v.toFixed(1)) {
    const start = performance.now();
    function step(now) {
      const t = Math.min(1, (now - start) / ms);
      const v = from + (to - from) * t;
      el.textContent = fmt(v);
      if (t < 1) requestAnimationFrame(step);
    }
    requestAnimationFrame(step);
  }

  function computeWastedAndGallagher(parties, allocatedSeats, magnitude) {
    const votesMap = {};
    let totalVotes = 0;
    parties.forEach(p => {
      const v = Number(p.votes) || Number(p.voteShare) || 0;
      votesMap[p.id] = v;
      totalVotes += v;
    });

    const wastedVotes = Object.keys(votesMap)
      .filter(id => (allocatedSeats[id] || 0) === 0)
      .reduce((s, id) => s + votesMap[id], 0);

    const votePct = {};
    const seatPct = {};
    Object.keys(votesMap).forEach(id => {
      votePct[id] = totalVotes > 0 ? (100 * votesMap[id] / totalVotes) : 0;
      seatPct[id] = magnitude > 0 ? (100 * ((allocatedSeats[id] || 0) / magnitude)) : 0;
    });

    let sumsq = 0;
    Object.keys(votePct).forEach(id => {
      const d = (votePct[id] || 0) - (seatPct[id] || 0);
      sumsq += d * d;
    });
    const gallagher = Math.sqrt(0.5 * sumsq);

    return {
      wastedPct: totalVotes > 0 ? (100 * wastedVotes / totalVotes) : 0,
      wastedVotes,
      totalVotes,
      gallagher
    };
  }

  // shorten long party names so they don't collide with numbers
  function shortenPartyName(raw, maxChars = 18) {
    if (!raw) return '';
    const s = String(raw).trim();
    if (s.length <= maxChars) return s;
    return s.slice(0, maxChars - 1) + '…'; // add ellipsis
  }

  // render metrics below the map
  function renderMetrics(engineResult) {
    if (!engineResult) return;
    console.log('[APP] renderMetrics input', engineResult);

    const { parties = [], allocatedSeats = {}, seatBonus = {}, magnitude } = engineResult;

    // previous party shares from last render (keeps id -> party object)
    const prevMap = window._lastPartiesMap || {};

    // --- build initial "top4" (2 gainers + 2 losers) then append remaining parties ---
    const byBonus = [...parties].sort((a, b) => (seatBonus[b.id] || 0) - (seatBonus[a.id] || 0));
    let gainers = byBonus.filter(p => (seatBonus[p.id] || 0) > 0).slice(0, 2);
    let losers = byBonus.slice().reverse().filter(p => (seatBonus[p.id] || 0) < 0).slice(0, 2);
    const picked = new Set([...gainers, ...losers].filter(Boolean).map(p => p.id));
    // fill to ensure we have at least some items
    const remainingByAbs = byBonus
      .filter(p => !picked.has(p.id))
      .sort((a,b) => Math.abs(seatBonus[b.id]||0) - Math.abs(seatBonus[a.id]||0));

    // fill missing gainers or losers from remaining to reach 2 each where possible
    for (const p of remainingByAbs) {
      if (gainers.length < 2 && !picked.has(p.id)) { gainers.push(p); picked.add(p.id); }
    }
    const remForLosers = byBonus.filter(p => !picked.has(p.id)).reverse();
    for (const p of remForLosers) {
      if (losers.length < 2 && !picked.has(p.id)) { losers.push(p); picked.add(p.id); }
    }

    // final ordered list: top4 (preferred) then rest by abs(bonus)
    const topPref = [...gainers.slice(0,2), ...losers.slice(0,2)].filter(Boolean);
    const rest = byBonus.filter(p => !topPref.find(tp => tp.id === p.id))
                      .sort((a,b) => Math.abs(seatBonus[b.id]||0) - Math.abs(seatBonus[a.id]||0));
    const ordered = [...topPref, ...rest];

    // chunk into pages of 4
    const pageSize = 3;
    const pages = [];
    for (let i = 0; i < ordered.length; i += pageSize) pages.push(ordered.slice(i, i + pageSize));

    // compute stats
    const { wastedPct, gallagher } = computeWastedAndGallagher(parties, allocatedSeats, magnitude || 1);

    // --- update "What changed here?" text with data-driven bullets ---
    (function updateChangeCard() {
      const intro = document.querySelector('.legend-intro');
      const ul = document.querySelector('.legend ul');
      if (!ul) return;

      // find top winner and top loser by seat bonus
      const bonusMap = (engineResult.seatBonus) ? engineResult.seatBonus : {};
      const entries = ordered.map(p => ({ id: p.id, name: (PARTY_NAMES[p.id]||p.name||p.id), bonus: (bonusMap[p.id]||0) }));
      const sortedByBonus = entries.slice().sort((a,b) => b.bonus - a.bonus);
      const topWinner = sortedByBonus.find(e => e.bonus > 0) || null;
      const topLoser  = sortedByBonus.slice().reverse().find(e => e.bonus < 0) || null;

      if (intro) {
        intro.textContent = `Key changes under Threshold ${Math.round(wastedPct) ? Math.round(wastedPct) : (readState().threshold+'%')} and ${Math.max(1, Math.round(magnitude||1))}-seat districts.`;
      }

      const bullets = [];
      if (topWinner) bullets.push(`<li><span class="dot blue"></span> ${topWinner.name} gained ${topWinner.bonus > 0 ? `+${topWinner.bonus}` : topWinner.bonus} seats.</li>`);
      if (topLoser)  bullets.push(`<li><span class="dot purple"></span> ${topLoser.name} lost ${topLoser.bonus < 0 ? Math.abs(topLoser.bonus) : topLoser.bonus} seats.</li>`);
      bullets.push(`<li><span class="dot red"></span> Wasted votes ≈ ${Math.round(wastedPct)}% — this affects small parties below the threshold.</li>`);

      ul.innerHTML = bullets.join('\n');
    })();

    // ensure all gauge elements receive the current value (prevents stale UI)
    const v = Math.max(0, Math.min(100, Math.round(wastedPct)));
    document.querySelectorAll('.metric.wasted .gauge, .gauge').forEach(g => {
      const size = 110;
      const thick = 12;
      const cx = size / 2;
      const cy = size / 2;
      const r = (size - thick) / 2;
      const c = +(2 * Math.PI * r).toFixed(2);
      const dashOffset = +(Math.round((1 - v / 100) * c)).toFixed(2);

      // build SVG markup + keep a span for the existing animateCount code
      g.innerHTML = `
        <svg class="gauge-svg" width="${size}" height="${size}" viewBox="0 0 ${size} ${size}" aria-hidden="true" focusable="false">
          <defs></defs>
          <!-- visible blue ring (background) -->
          <circle class="g-bg" cx="${cx}" cy="${cy}" r="${r}" stroke-width="${thick}" fill="none"/>
          <!-- active arc on top -->
          <circle class="g-arc" cx="${cx}" cy="${cy}" r="${r}"
            stroke-width="${thick}"
            stroke-dasharray="${c} ${c}"
            stroke-dashoffset="${dashOffset}"
            fill="none" />
        </svg>
        <span>${Math.round(v)}%</span>
      `;

      // animate arc when value changes
      const arc = g.querySelector('.g-arc');
      if (arc) {
        arc.style.transition = 'stroke-dashoffset 900ms cubic-bezier(.2,.9,.2,1)';
      }
      // ensure animateCount still updates the visible percentage in the span above
      g.style.willChange = 'contents';
    });

    // --- Update below-map DOM elements ---
    try {
      // wasted votes
      const wastedSpan = document.querySelector('.metric.wasted .gauge span') || document.querySelector('.metric.wasted .kpi .num');
      if (wastedSpan) {
        const current = parseFloat((wastedSpan.textContent || '0').replace('%', '')) || 0;
        animateCount(wastedSpan, current, wastedPct, 900, v => `${Math.round(v)}%`);
      }

      // disproportionality
      const diNum = document.querySelector('.metric.di .kpi .num') || document.querySelector('.metric.dispro .num');
      if (diNum) {
        const cur = parseFloat(diNum.textContent) || 0;
        animateCount(diNum, cur, gallagher, 900, v => v.toFixed(1));
      }

      // seat-bonus area
      const seatMetric = document.querySelector('.metric.seat-bonus');
      if (seatMetric) {
        // hide placeholder chips (if not removed in CSS)
        const legendChips = seatMetric.querySelector('.legend-chips');
        if (legendChips) legendChips.style.display = 'none';

        // ensure top-list container — append into .seat-bonus-top if present
        const seatTop = seatMetric.querySelector('.seat-bonus-top') || seatMetric;

        let topList = seatTop.querySelector('.top-list') || seatMetric.querySelector('.top-list');
        if (!topList) {
          topList = document.createElement('div');
          topList.className = 'top-list';
          topList.style.marginTop = '12px';
          seatTop.appendChild(topList);
        }

        // ensure pager controls are in the same top area and placed after the table
        const oldPager = seatTop.querySelector('.top-pager') || seatMetric.querySelector('.top-pager');
        if (oldPager) oldPager.remove();

        pager = document.createElement('div');
        pager.className = 'top-pager';
        pager.innerHTML = `
          <button type="button" class="pager-btn prev" aria-label="Prev page">
            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" aria-hidden="true"><path d="M15 18l-6-6 6-6" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>
          </button>
          <div class="pager-dots" role="tablist" aria-label="Pages"></div>
          <button type="button" class="pager-btn next" aria-label="Next page">
            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" aria-hidden="true"><path d="M9 6l6 6-6 6" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>
          </button>
        `;

        // Insert pager right after the topList so dots sit below the table
        if (topList.nextSibling) {
          seatTop.insertBefore(pager, topList.nextSibling);
        } else {
          seatTop.appendChild(pager);
        }

        const dotsRoot = pager.querySelector('.pager-dots');
        dotsRoot.innerHTML = pages.map((_, idx) => `<button class="dot" data-idx="${idx}" aria-label="Page ${idx+1}"></button>`).join('');

        // safe wiring: only attach handlers if buttons exist
        const prevBtn = pager.querySelector('.prev');
        const nextBtn = pager.querySelector('.next');

        if (prevBtn) prevBtn.addEventListener('click', () => {
          let i = Number(seatMetric.dataset.rmPageIndex || 0);
          i = Math.max(0, i - 1);
          renderPage(i);
        });
        if (nextBtn) nextBtn.addEventListener('click', () => {
          let i = Number(seatMetric.dataset.rmPageIndex || 0);
          i = Math.min(pages.length - 1, i + 1);
          renderPage(i);
        });

        dotsRoot.addEventListener('click', (ev) => {
          const btn = ev.target.closest('button[data-idx]');
          if (!btn) return;
          const idx = Number(btn.dataset.idx || 0);
          renderPage(idx);
        });

        // store current page index on element
        let pageIndex = Number(seatMetric.dataset.rmPageIndex || 0);
        pageIndex = Math.min(pageIndex, Math.max(0, pages.length - 1));
        seatMetric.dataset.rmPageIndex = String(pageIndex);

        function renderPage(idx) {
          const page = pages[idx] || [];
          // build rows
          const palette = { gain: '#10B981', lose: '#EF4444', neutral: '#94A3B8' };
          // column header (Party | Bonus | Seats)
          const header = `
            <div class="top-row header" aria-hidden="true">
              <div class="dot header-dot"></div>
              <div class="name-wrap header-label">Party</div>
              <div class="votes header-label">% Votes</div>
              <div class="bonus header-label">Bonus</div>
              <div class="allocated header-label">Seats</div>
            </div>
          `;
          const rowsHtml = page.map(p => {
            const id = p.id || p.name || '—';
            const fullName = (window.PARTY_NAMES && window.PARTY_NAMES[id]) || p.name || id;
            const shortName = shortenPartyName(fullName, 40);
            // const shortName = fullName;
            const display = shortName || fullName;
            const esc = s => String(s || '').replace(/"/g, '&quot;');
            const bonus = seatBonus[p.id] || 0;
            // const votesPct = (Number(p.voteShare) || 0).toFixed(2) + '%';
            // show "x% → y%" when we have a previous render stored in window._lastPartiesMap
            let prevVal = null;
            if (prevMap && prevMap[id]) {
              prevVal = typeof prevMap[id].voteShare !== 'undefined' ? Number(prevMap[id].voteShare) :
                        (typeof prevMap[id].votes !== 'undefined' ? Number(prevMap[id].votes) : null);
            }
            const newVal = Number(p.voteShare || p.votes) || 0;
            // build HTML for votes column (allow full HTML insertion)
            const votesHtml = prevVal !== null
              ? `<div class="votes"><span class="votes-prev">${prevVal.toFixed(2)}%</span> <span class="votes-arrow">→</span> <span class="votes-new">${newVal.toFixed(2)}%</span></div>`
              : `<div class="votes">${newVal.toFixed(2)}%</div>`;
            const allocated = allocatedSeats && typeof allocatedSeats[p.id] !== 'undefined'
              ? allocatedSeats[p.id]
              : null;
            const type = bonus > 0 ? 'gain' : (bonus < 0 ? 'lose' : 'neutral');
            const color = palette[type];
            return `
              <div class="top-row" data-id="${id}">
                <div class="dot" style="background:${color}"></div>
                <div class="name-wrap">
                  <div class="party-name" title="${esc(fullName)}" aria-label="${esc(fullName)}">${display}</div>
                </div>
                ${votesHtml}
                <div class="bonus">${bonus>0?'+':''}${bonus}</div>
                <div class="allocated">${allocated !== null ? allocated + 's' : ''}</div>
              </div>`;
          }).join('');

          // prepend header so columns have labels
          topList.innerHTML = header + rowsHtml;
          // remember this render's shares so next Apply can show prev -> new
          try {
            window._lastPartiesMap = Object.fromEntries((parties || []).map(pp => [pp.id || pp.name || '—', { voteShare: pp.voteShare, votes: pp.votes }]));
          } catch (e) { /* ignore assignment errors */ }

          // update dots active
          Array.from(dotsRoot.children).forEach((el,i) => el.classList.toggle('active', i === idx));
          // persist index
          seatMetric.dataset.rmPageIndex = String(idx);
        }

        // wire pager buttons + dots (delegated)
        pager.querySelector('.prev').addEventListener('click', () => {
          let i = Number(seatMetric.dataset.rmPageIndex || 0);
          i = Math.max(0, i - 1);
          renderPage(i);
        });
        pager.querySelector('.next').addEventListener('click', () => {
          let i = Number(seatMetric.dataset.rmPageIndex || 0);
          i = Math.min(pages.length - 1, i + 1);
          renderPage(i);
        });
        dotsRoot.addEventListener('click', (ev) => {
          const btn = ev.target.closest('button[data-idx]');
          if (!btn) return;
          const idx = Number(btn.dataset.idx || 0);
          renderPage(idx);
        });

        // initial render
        renderPage(pageIndex);
      } else {
        console.debug('[APP] seat-bonus metric container not found');
      }
    } catch (e) {
      console.debug('[APP] renderMetrics update error', e && e.message);
    }

    // --- Logging: console + IDE receiver ---
    console.log('[APP] metrics computed', {
      orderedSample: ordered.slice(0,8).map(p=>({ id:p.id, bonus: seatBonus[p.id] })),
      wastedPct, gallagher
    });

    try {
      const payload = {
        ts: new Date().toISOString(),
        source: 'app.metrics',
        country: engineResult.countryName || engineResult.country || null,
        formula: engineResult.formula || null,
        magnitude: engineResult.magnitude || magnitude || null,
        orderedSample: ordered.slice(0,8).map(p => ({ id: p.id, name: p.name, voteShare: p.voteShare, bonus: seatBonus[p.id] })),
        wastedPct, gallagher
      };
      fetch('http://127.0.0.1:9999/log', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload),
        keepalive: true
      }).catch(e => console.debug('[APP] local log receiver not reachable:', e && e.message));
    } catch (e) { /* ignore */ }
  }

  // --- show a default "empty" placeholder UI before any data is applied ---
  function renderEmptyMetricsPlaceholder() {
    const seatMetric = document.querySelector('.metric.seat-bonus');
    if (!seatMetric) return;
    const seatTop = seatMetric.querySelector('.seat-bonus-top') || seatMetric;
    let topList = seatTop.querySelector('.top-list');
    if (!topList) {
      topList = document.createElement('div');
      topList.className = 'top-list';
      topList.style.marginTop = '12px';
      seatTop.appendChild(topList);
    }

    const header = `
      <div class="top-row header">
        <div class="header-dot"></div>
        <div class="name-wrap header-label">PARTY</div>
        <div class="votes header-label">% VOTES</div>
        <div class="bonus header-label">BONUS</div>
        <div class="allocated header-label">SEATS</div>
      </div>`;

    const emptyRow = `
      <div class="top-row empty">
        <div class="dot" aria-hidden="true"></div>
        <div class="name-wrap"><div class="party-name">—</div></div>
        <div class="votes"><span class="votes-new">—</span></div>
        <div class="bonus">/</div>
        <div class="allocated">/</div>
      </div>`;

    topList.innerHTML = header + emptyRow;

    // ensure pager exists and show a single dot
    let pager = seatTop.querySelector('.top-pager');
    if (!pager) {
      pager = document.createElement('div');
      pager.className = 'top-pager';
      seatTop.appendChild(pager);
    }
    pager.innerHTML = `<div class="pager-dots"><div class="dot"></div></div>`;

    // set wasted gauge text to 0% and DI to 0.0
    const wastedSpan = document.querySelector('.metric.wasted .gauge span') || document.querySelector('.metric.wasted .kpi .num');
    if (wastedSpan) wastedSpan.textContent = '0%';
    const diNum = document.querySelector('.metric.di .kpi .num') || document.querySelector('.metric.dispro .num');
    if (diNum) diNum.textContent = '0.0';

    // rebuild gauge SVGs (if the gauge is rendered by JS) so arc is empty
    document.querySelectorAll('.metric.wasted .gauge, .gauge').forEach(g => {
      const size = 110;
      const thick = 12;
      const cx = size / 2;
      const r = (size - thick) / 2;
      const c = +(2 * Math.PI * r).toFixed(2);
      const dashOffset = c; // full offset => 0% visible
      g.innerHTML = `
        <svg class="gauge-svg" width="${size}" height="${size}" viewBox="0 0 ${size} ${size}" aria-hidden="true" focusable="false">
          <circle class="g-bg" cx="${cx}" cy="${cx}" r="${r}" stroke-width="${thick}" fill="none"/>
          <circle class="g-arc" cx="${cx}" cy="${cx}" r="${r}"
            stroke-width="${thick}"
            stroke-dasharray="${c} ${c}"
            stroke-dashoffset="${dashOffset}"
            fill="none" />
        </svg>
        <span>0%</span>
      `;
    });

    // muted styling for placeholder (keeps it visually distinct)
    const emptyRows = topList.querySelectorAll('.top-row.empty');
    emptyRows.forEach(r => r.style.color = 'var(--gray-400, #9AA3B3)');

    // legend text defaults
    const legendIntro = document.querySelector('.legend .legend-intro');
    const legendUl = document.querySelector('.legend ul');
    if (legendIntro) {
      legendIntro.textContent = 'No scenario applied. Adjust controls and click Apply to preview changes.';
    }
    if (legendUl) {
      legendUl.innerHTML =
        '<li><span class="dot blue" aria-hidden="true"></span> No parties crossed.</li>' +
        '<li><span class="dot purple" aria-hidden="true"></span> Seats unchanged.</li>' +
        '<li><span class="dot red" aria-hidden="true"></span> Wasted: 0% · DI: 0.0</li>';
    }
  }

  // expose for manual testing
  window.renderMetrics = renderMetrics;

  const jumpToResults = () => document.querySelector('#results')?.scrollIntoView({behavior:'smooth', block:'start'});

  function showFabAttention(){
      if (!allowFab) return;
      if (!viewFab) return;
      fabAutoHidden = false;
      viewFab.classList.remove('is-hidden');
      viewFab.classList.remove('is-bounce'); void viewFab.offsetWidth;
      viewFab.classList.add('is-bounce');
  }

  // scroll helper: jump a bit further past the top of #results
  function scrollToResults(offset = 140, delay = 80){
    const el = document.querySelector('#results');
    if (!el) return;
    setTimeout(() => {
      const top = el.getBoundingClientRect().top + window.scrollY + offset;
      window.scrollTo({ top, behavior: 'smooth' });
    }, delay);
  }

  // FAB click: hide FAB and scroll further down to results
  viewFab?.addEventListener('click', (e) => {
    e.preventDefault();
    // hide FAB immediately
    viewFab.classList.add('is-hidden');
    try { viewFab.blur(); } catch (err) {}
    // scroll a bit further down for an extra reveal (tune offset/delay as needed)
    scrollToResults(140, 100);
  });

  // ---------- lightweight bottom-centered error toast ----------
  function ensureErrorToast() {
    let toast = document.querySelector('.rm-error-toast');
    if (!toast) {
      toast = document.createElement('div');
      toast.className = 'rm-error-toast';
      toast.setAttribute('role', 'status');
      toast.setAttribute('aria-live', 'polite');

      const dot = document.createElement('span'); dot.className = 'rm-error-toast__dot';
      const text = document.createElement('span'); text.className = 'rm-error-toast__text';
      toast.appendChild(dot); toast.appendChild(text);
      document.body.appendChild(toast);

      Object.assign(toast.style, {
        position: 'fixed',
        left: '50%',
        zIndex: '1405',
        transform: 'translateX(-50%) translateY(0)',
        minWidth: '260px',
        maxWidth: '640px',
        padding: '0.6rem 1rem',
        borderRadius: '999px',
        display: 'flex',
        alignItems: 'center',
        gap: '.6rem',
        background: '#FEE2E2',
        color: '#7F1D1D',
        boxShadow: '0 10px 30px rgba(31,41,55,0.12)',
        fontSize: '0.95rem',
        opacity: '0',
        pointerEvents: 'none',
        transition: 'opacity .18s ease, transform .18s ease, bottom .12s ease',
      });

      Object.assign(dot.style, {
        width: '8px',
        height: '8px',
        borderRadius: '999px',
        background: '#DC2626',
        flexShrink: '0'
      });

      Object.assign(text.style, {
        display: 'inline-block'
      });
    }
    return toast;
  }

  function showErrorToast(message) {
    const toast = ensureErrorToast();
    const textEl = toast.querySelector('.rm-error-toast__text');
    if (textEl) textEl.textContent = message;

    const bottomForNarrow = 48;
    const bottomForWide = 56;
    const bottom = window.innerWidth >= 1400 ? bottomForWide : bottomForNarrow;
    toast.style.bottom = `${bottom}px`;

    if (toast._hideTimer) clearTimeout(toast._hideTimer);

    // show
    toast.style.opacity = '1';
    toast.style.pointerEvents = 'auto';
    toast.style.transform = 'translateX(-50%) translateY(0)';

    // hide after timeout
    toast._hideTimer = setTimeout(() => {
      toast.style.opacity = '0';
      toast.style.transform = 'translateX(-50%) translateY(8px)';
      toast.style.pointerEvents = 'none';
    }, 2800);
  }

  // ---------- Apply / validation ----------
  function applyChanges({scroll = false, userTriggered = false} = {}) {
    // read UI state and update legend immediately
    const s = readState();
    console.log('[APP] applyChanges start', s);
    renderLegend(s);

    if (userTriggered) setTimeout(showFabAttention, 260);
    if (applyBtn) try { applyBtn.blur(); } catch (e) {}
    if (scroll && window.innerWidth < 1600) setTimeout(jumpToResults, 80);

    // debug: confirm data + engine presence
    const ep = window.epData || window.EP2024 || null;
    console.log('[APP] epData present?', !!ep, 'EPEngine present?', !!window.EPEngine);

    // robust matcher (keeps previous logic)
    function findCountryData(ep, countryLabel) {
      if (!ep) return null;
      if (ep[countryLabel]) { console.log('[APP] matched country by key:', countryLabel); return ep[countryLabel]; }
      const mappedCode = (typeof EU_CODES !== 'undefined') ? EU_CODES[countryLabel] : null;
      if (mappedCode && ep[mappedCode]) { console.log('[APP] matched country by name->code:', countryLabel, '->', mappedCode); return ep[mappedCode]; }
      const ciKey = Object.keys(ep).find(k => k.toLowerCase() === (countryLabel||'').toLowerCase());
      if (ciKey) { console.log('[APP] matched country by key (ci):', ciKey); return ep[ciKey]; }
      const byInnerName = Object.values(ep).find(v => v && v.name && String(v.name).toLowerCase() === (countryLabel||'').toLowerCase());
      if (byInnerName) { console.log('[APP] matched country by inner name:', byInnerName.name); return byInnerName; }
      const up = (countryLabel||'').toUpperCase().slice(0,2);
      if (up && ep[up]) { console.log('[APP] fallback matched by first-two-chars:', up); return ep[up]; }
      console.warn('[APP] findCountryData: no match for', countryLabel);
      return null;
    }

    const cData = findCountryData(ep, s.country);
    console.log('[APP] cData lookup result:', cData ? (cData.name || cData.countryCode || 'object') : null);

    if (!cData) {
      // show a user-facing toast only when the user explicitly clicked Apply
      if (userTriggered) {
        if (!s.country) {
          showErrorToast('Please select a country and click Apply.');
          allowFab = false;
          if (viewFab) viewFab.classList.add('is-hidden');
        } else {
          showErrorToast('Country data not available. Try again in a moment.');
          // if (viewFab) viewFab.classList.add('is-hidden');
        }
      }

      // if (!cData) {
      //     allowFab = false;
      //     viewFab.classList.add('is-hidden');

      //     if (!s.country) {
      //         showErrorToast('Please select a country and click Apply.');
      //     }
      //     return;
      // }

      // keep the View FAB hidden when we can't proceed
      if (viewFab) viewFab.classList.add('is-hidden');

      if (downloadBtn) {
        downloadBtn.classList.add('is-disabled');
        downloadBtn.setAttribute('aria-disabled', 'true');
      }

      // showErrorToast('Country data not loaded yet. Try again in a moment.');
      // POST a short dev log so you see in IDE why it failed
      try {
        fetch('http://127.0.0.1:9999/log', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ ts: new Date().toISOString(), source: 'app.apply', ok: false, reason: 'no_country_data', requested: s.country })
        }).catch(()=>{ /* ignore */ });
      } catch (e) { /* ignore */ }
      console.warn('[APP] epData missing for', s.country, ep);
      return;
    }

    if (!window.EPEngine || typeof window.EPEngine.computeScenario !== 'function') {
      showErrorToast('Engine not ready. Try reloading the page.');
      if (viewFab) viewFab.classList.add('is-hidden');
      if (downloadBtn) {
        downloadBtn.classList.add('is-disabled');
        downloadBtn.setAttribute('aria-disabled', 'true');
      }
      console.warn('[APP] EPEngine missing or not ready', !!window.EPEngine);
      try {
        fetch('http://127.0.0.1:9999/log', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ ts: new Date().toISOString(), source: 'app.apply', ok: false, reason: 'engine_missing', requested: s.country })
        }).catch(()=>{ /* ignore */ });
      } catch (e) { /* ignore */ }
      return;
    }

    // compute scenario using engine
    let result = null;
    try {
      result = window.EPEngine.computeScenario(cData, s);
      console.log('[APP] computeScenario result', result);
    } catch (err) {
      console.error('[APP] computeScenario threw', err);
      showErrorToast('Computation failed. See console.');
      if (viewFab) viewFab.classList.add('is-hidden');
      if (downloadBtn) {
        downloadBtn.classList.add('is-disabled');
        downloadBtn.setAttribute('aria-disabled', 'true');
      }
      try {
        fetch('http://127.0.0.1:9999/log', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ ts: new Date().toISOString(), source: 'app.apply', ok: false, reason: 'compute_error', error: String(err), requested: s.country })
        }).catch(()=>{ /* ignore */ });
      } catch (e) { /* ignore */ }
      return;
    }

    if (result) {
      allowFab = true;

      // reset seat-bonus pager to the first page when Apply is pressed
      try {
        const seatMetric = document.querySelector('.metric.seat-bonus');
        if (seatMetric) {
          seatMetric.dataset.rmPageIndex = '0';
        }
      } catch (err) { /* ignore */ }

      // UI updates
      renderMetrics(result);
      if (typeof renderMap === 'function') renderMap(result);
      renderLegend(s);

      // expose last engine result for PDF generation
      window._lastEngineResult = result;

      if (downloadBtn) {
        downloadBtn.classList.remove('is-disabled');
        downloadBtn.removeAttribute('aria-disabled');
      }

      // send detailed metrics to IDE log-receiver
      try {
        const payload = {
          ts: new Date().toISOString(),
          source: 'app.apply',
          ok: true,
          requested: s.country,
          state: s,
          top4: (result.parties || []).slice(0,4).map(p => ({ id:p.id, name:p.name, voteShare:p.voteShare, allocated:(result.allocatedSeats||{})[p.id] })),
          wastedPct: (result && typeof result.magnitude !== 'undefined') ? computeWastedAndGallagher(result.parties, result.allocatedSeats, result.magnitude).wastedPct : null,
          gallagher: (result && typeof result.magnitude !== 'undefined') ? computeWastedAndGallagher(result.parties, result.allocatedSeats, result.magnitude).gallagher : null
        };
        fetch('http://127.0.0.1:9999/log', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload)
        }).catch(e => console.debug('[APP] local log receiver not reachable:', e && e.message));
      } catch (e) { /* ignore */ }

      // dispatch global event for other listeners (e.g. map)
      try {
        const selectedCountryCode = window.CurrentCountryCode
          || (typeof EU_CODES !== 'undefined' && EU_CODES[s.country])
          || s.country;

        window.dispatchEvent(new CustomEvent('rm:apply', {
          detail: { selectedCountry: selectedCountryCode, state: s }
        }));
      } catch (err) {
        console.debug('[APP] rm:apply dispatch failed', err && err.message);
      }
    }
  }

  // Apply button: render + reveal FAB with bounce
  applyBtn?.addEventListener('click', (e)=>{ e.preventDefault(); applyChanges({scroll:false, userTriggered:true}); });

  // document.querySelector(".action.apply").addEventListener("click", () => {
  //   const selectedCountry = window.CurrentCountryCode;
  //   const state = collectUIState();

  //   window.dispatchEvent(new CustomEvent("rm:apply", {
  //     detail: { selectedCountry, state }
  //   }));
  // });

  document.addEventListener('click', (e) => {
    // ignore clicks that occur immediately after a toggle click (debounce)
    const last = window.__lastDropdownToggle || 0;
    const now = (typeof performance !== 'undefined') ? performance.now() : Date.now();
    if (now - last < 250) return;
    if (!e.target.closest('.dropdown')) Dropdowns.closeAll();
  });
  document.addEventListener('keydown', (e)=>{ if (e.key==='Escape') Dropdowns.closeAll(); });

  // initial legend render without revealing the FAB
  applyChanges({scroll:false, userTriggered:false});

  // close popups when clicking anywhere else
  document.addEventListener('click', () => {
    document.querySelectorAll('.info-popup.is-open').forEach(p => p.classList.remove('is-open'));
  });

  // close on Escape for accessibility
  document.addEventListener('keydown', (e) => {
    if (e.key === 'Escape') {
      document.querySelectorAll('.info-popup.is-open').forEach(p => p.classList.remove('is-open'));
    }
  });

  // ---------- methods accordion ----------
  const methodsCard = document.querySelector('.methods-card');
  if (methodsCard) {
    const toggle = methodsCard.querySelector('.collapse-toggle');
    const body = methodsCard.querySelector('.methods-body');

    // helper: animate open/close using explicit heights
    function expand(el){
      el.style.display = '';
      const full = el.scrollHeight + 'px';
      el.style.height = '0px';
      el.style.opacity = '0';
      // kick off transition on next frame
      requestAnimationFrame(() => {
        el.style.transition = 'height .34s cubic-bezier(.2,.9,.2,1), opacity .18s ease';
        el.style.height = full;
        el.style.opacity = '1';
      });
      function done(e){
        if (e.propertyName === 'height') {
          el.style.height = 'auto';
          el.removeEventListener('transitionend', done);
        }
      }
      el.addEventListener('transitionend', done);
    }

    function collapse(el){
      // from auto -> explicit px so transition works
      el.style.height = el.scrollHeight + 'px';
      // force a frame then set to 0
      requestAnimationFrame(() => {
        el.style.transition = 'height .28s cubic-bezier(.2,.9,.2,1), opacity .14s ease';
        el.style.height = '0px';
        el.style.opacity = '0';
      });
      function done(e){
        if (e.propertyName === 'height') {
          el.style.display = 'none';
          el.removeEventListener('transitionend', done);
        }
      }
      el.addEventListener('transitionend', done);
    }

    if (body) {
      if (methodsCard.classList.contains('is-collapsed')) {
        body.style.display = 'none';
        body.style.height = '0px';
        body.style.opacity = '0';
      } else {
        body.style.height = 'auto';
        body.style.opacity = '1';
      }
    }

    toggle?.addEventListener('click', (e) => {
      e.preventDefault();
      const expanded = toggle.getAttribute('aria-expanded') === 'true';
      toggle.setAttribute('aria-expanded', String(!expanded));
      methodsCard.classList.toggle('is-collapsed');

      if (!body) return;
      if (methodsCard.classList.contains('is-collapsed')) {
        collapse(body);
      } else {
        expand(body);
      }
    });
  }
});
